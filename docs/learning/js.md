## javascript

### JS 简介

- JS 是一门编程语言，具有逻辑描述能力

  - 数学逻辑
  - 功能逻辑（业务逻辑）

- js 历史

  - 出现的目的是为了做一些简单的表单验证
  - NetScape（网景）公司研发的 NetScape Navigator1.0（浏览器）
  - 1995 年，Brendan Eich（布兰登·艾奇）发明
  - 标准语法 ECMAScript（欧洲计算机制造联合会）

### 组成部分

ECMAScript 核心语法

- DOM（Document Object Model）文档对象模型，操作网页内容的一套 API
- BOM（Browser Object Model）浏览器对象模型，操作浏览器的一套 API

### 书写方式

- 行内 JS

  ```html
  <input type="button" onclick="alert('hello world')" />
  ```

- 内部 JS

  ```html
  <script>
    alert("hello word");
  </script>
  ```

- 外联 JS

  ```html
  <script src="js文件路径"></script>
  ```

### 输出内容的方式

- 弹出警告框 alert('你好');
- 控制台输出目录 console.dir();
- 控制台输出内容 console.log('你好');
- 在网页中打印 document.write('你好');
- 接收用户输入的内容 prompt('请输入账号');

### 调试 sources

- 语法错误

  - alert()
  - console.log()

- 逻辑错误

  - 断点调试

## 变量

**变量就是向内存中所申请的一块空间，空间中存放着数据**

### 变量创建与使用

- 创建变量 var

  ```javascript
  var age;
  ```

- 变量赋值

  ```javascript
  var age;
  age = 123;
  ```

- 变量初始化

  ```javascript
  var age = 123;
  ```

- 批量创建和批量赋值

  ```javascript
  var age, name, sex;
  (age = 123), (name = "张三"), (sex = "男");
  ```

- 批量初始化

  ```javascript
  var age = 123,
    name = "张三",
    sex = "男";
  ```

- 重复赋值

  ```javascript
  var age = 123;
  console.log(age);
  var age = 456;
  console.log(age);
  ```

- 赋值另一个变量

  ```javascript
  var a = 123;
  var b = a;
  ```

### 变量命名规范

- 由数字、字母、下划线\_、$符组成
- 不能以数字开头
- 不能使用关键字或保留字当做变量名
- 变量名区分大小写
- 驼峰命名法
- 第一个单词首字母小写，后边单词首字母大写

## 数据类型

**能被输出的内容就是数据**

### 检测基本数据类型

typeof(数据);

### Number 数字类型

- 数字字面量

  > 1 10 3.14 -1 0

- 进制

  > 十进制 0-9
  > 八进制 01-07
  > 十六进制 0-9 及 a-f

- 浮点数（小数）

  > 3.14 -2.2
  > 精度丢失时需要把小数转换成整数计算

- NaN

  > Not a Number
  > 不是正常数字，是 Number 数字类型
  > isNaN(数据) 返回 是-true 不是-false

- 数值范围

  > 最大值 Number.MIN_VALUE 5e-324（科学计数法：5 乘以 10 的负的 324 次方）
  > 最小值 Number.MAX_VALUE 1.7976931348623157e+308
  > 无穷大 Infinity 正数数字和 0 相除的结果
  > 无穷小 -Infinity 负数数字和 0 相除的结果

### String 字符串类型

- 单或双引号所包裹的字符
- 单双引号嵌套
- 转义符（去除特殊含义） \
  - \\' 把一个单引号转换为普通字符
  - \\" 把一个双引号转换为普通字符
- 拼接符（连接符） +

### Boolean 布尔类型

- 比较判断或逻辑判断
- true 表示程序中的肯定
- false 表示程序中的否定

### Undefined 类型

- 表示未定义，仅有一个值 undefined
- 若一个变量没有赋值时，默认值是 undefined

### Null 类型

- 表示空（空对象），仅有一个值 null
- 检测显示 object

## 运算符

### 算术运算符

- 加 +
- 减 -
- 乘 \*
- 除 /
- 取余数（取模） %
  - 整除 余数
  - 不能整除本身

### 赋值运算符--针对的是变量

- =
- +=
- -=
- \*=
- /=
- %=

### 关系(比较)运算符--结果都是布尔值

- 大于 >
- 小于 <
- 大于等于 >=
- 小于等于 <=
- 不等于 !=
- 等于 ==
  - 只比较值
  - 特殊的例子 undefined == null // true
- 全等 ===
  - 基本数据类型 比较数据值和基本的数据类型
  - 引用数据类型 比较数据值和变量内存地址
- 不全等 !==

### 逻辑运算符--针对布尔值

- 与 &&

  - 逻辑与（且）运算
  - 当&&左右两边的结果都是 true 时，结果就是 true,其他结果是 false

- 或 ||

  - 逻辑或运算
  - 当||左右两边有任意一个结果是 true 时，结果就是 true,其他是 false

- 非 !

- 逻辑非（取反）运算

### 一元运算符

- 运算符运算的数据只有一个

  - 自增、自减、正号、负号、取反、typeof、delete

- 自增 ++ ,对变量实现数字自增 1

  - 前置自增

    - ++变量
    - 变量自身先加 1，再把结果返回到表达式中

  - 后置自增

    - 变量++
    - 先返回结果到表达式中，变量再自身加 1

- 自减 --，对变量实现数字自减 1

  - 前置自减

    - --变量
    - 变量自身先减 1，再把结果返回到表达式中

  - 后置自减

    - 变量--
    - 先返回结果到表达式中，变量再自身减 1

- 非 !

### 二元运算符

- 运算符运算的数据只有两个
- 算术运算符，关系(比较)运算符，逻辑运算符

### 三元运算符（三元表达式）

- 运算符运算的数据只有三个

  ```javascript
  条件表达式？结果 1：结果 2；
  ```

### 运算符的优先级

- ① 小括号 ()
- ② 一元运算符 ++、--、+、-、!、typeof、delete
- ③ 算术运算符 +、-、\*、/、% （先乘除取余数再加减）
- ④ 关系(比较)运算符 >、 <、 >=、 <=、 ==、 !=、 ===、 !==
- ⑤ 逻辑运算符 &&、 ||、! （先&& ，后||）
- ⑥ 赋值运算符 =、 +=、-=、\*=、/=、%=

## 数据类型转换

> 转换后会返回新的结果

### 检测

typeof() 检测变量或数据，返回数据的类型

### 强制转换

- 转字符串

  - String(其他数据);

    - Boolean、NaN、Undefined 和 Null 可以转字符串

  - 变量.toString();

    - Boolean、NaN、Undefined 和 Null 无法转字符串
    - 变量.toString() → 临时对象 想当于 new Number();去调用 toString()

- 转数字

  - Number(其他数据);

    - 数值字符串转数字 数字（number）

    - 非数值字符串转数字 NaN（number）

    - 布尔值转数字

      - true 1（number）

      - false 0（number）

    - undefined 转数字 NaN（number）

    - null 转数字 0（number）

  - parseInt(其他数据)；转换成整数

    - 只有数值和数值字符串能转换成数字 parseInt('100abc');→100

    - 转其他数据 NaN（number）

  - parseFloat(其他数据)；转换成小数

    - 只有数值和数值字符串 能转数字
    - NaN（number）

- 转布尔

  - Boolean(其他数据)
    - true
    - 空字符串' '、undefined、null、NaN、0 转换布尔值是 false

### 隐式转换

- 转字符串

  - 任何数据和字符串相加

- 转数字

  - 任何数据在做算术运算时（除了和字符串相加外）

  - 任何数据在和数字比较时

  - 任何数据和 NaN 做算术运算[NaN 自身、0、取余]（除了和字符串相加外），结果始终都是 NaN

- 转布尔

  - 在取反运算时
  - 在分支结构或循环结构的条件判断中

## 表达式和语句

### 表达式

- 可以由变量、数据、运算符组成，并产生运算结果的语法结构

  - 一元表达式
  - 二元表达式

- 一个表达式可以产生一个值（运算、函数调用、字面量）

- 表达式可以放在任何需要值的地方

### 语句

- 一个行为，用分号隔开一个个语句
- 条件判断语句、循环语句

## 流程控制

### 顺序结构

js 程序的默认执行顺序，从左向右，自上而下

### 分支结构

- if 分支

```javascript
if (条件表达式) {
  // 要执行的代码块
}
// 若条件表达式的结果是 true，则会执行大括号中的代码块
// 否则不执行;
```

- if-else 分支

```javascript
if (条件表达式) {
  // 要执行的代码块 1
} else {
  // 要执行的代码块 2
}
// 若条件表达式的结果是 true，则会执行大括号中的代码块 1
// 否则 false 执行代码块 2
```

- 三元表达式（三目运算符）

```javascript
// 条件表达式？结果 1：结果 2；
// 简化版 if-else
// 若条件表达式的结果是 true,则执行并返回结果 1
// 否则执行并返回结果 2
```

- if-else if...else 多分支

```javascript
  if(条件表达式 1){
    // 要执行的代码块 1
    } else if(条件表达式 2){
    // 要执行的代码块 2
    } else {
    // 其他代码块
    }

  // 若条件表达式 1 的结果是 true，则会执行代码块 1，并结束该分支结构
  // 否则继续向下判断条件表达式 2，依次类推
```

- switch case 结构

```javascript
switch(传入的值){
	case 值 1:
	// 执行语句
	break;
	case 值 2:
	// 执行语句
	break;
	/_..._/
	default:
	// 执行语句
	break;
}

// 做等值（全等）判断
// 让传入的值和以下各种值全等比较，符合执行应的代码
// 否则依次向下比较
// 若以上的值都不成立，则执行 default(可有可无，按需使用)对应的代码

// break 关键字（可有可无，按需使用）
// 当执行了 break 关键字时，会结束 switch 结构
```

### 循环结构

- while 循环

- while (循环条件) {
  //循环体
  } - 当循环条件为 true 时，执行循环体
  当循环条件为 false 时，结束循环

- do...while 循环

- do {

// 循环体;
} while (循环条件); - 不管条件成不成立，都会执行一次，然后是否周而复始的执行循环体，根据条件表达式是否成立决定\*\*

- for 循环

- for (初始化表达式 1; 判断表达式 2; 自增表达式 3) {

// 循环体 4
} - 执行顺序： 1 2 4 3 → 2 4 3 → 2 4 3 ...\*\*

- 三种循环的区分

- do-while 循环

- 不论条件是否成立，循环体必须执行一次

- while 循环

- 当循环次数不确定时

- for 循环

- 当循环次数确定时

- break

- 立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号）

- continue

- 立即跳出当前循环，继续下一次循环

- 死循环

- 永无休止的循环

## 数组

### 数组是一组有序的数据的集合

- 可以存储一组数据交给一个变量统一管理，并且可以方便的维护和操作

### 创建

- 通过构造函数 Array

- var 变量名 = new Array(数据,数据,数据,数据);

- 数组字面量

- var 变量名 = [数据,数据,数据,数据];

### 检测数组类型

- Array.isArray(值)

- 只兼容 IE9 以上

- 值 instanceof Array
- 值.constructor=== Array
- Object.prototype.toString.call()

### 读取和设置数组

- 有序指的是数组中数据的编号（索引、下标）是有序的，索引从 0 开始数
- 获取数据

- 数组名[索引];

- 设置数据

- 数组名[索引] = 新的数据;

### length 属性

- 获取数组中元素的个数

- 数组名.length;
- 索引：从 0 开始数
- 长度：从 1 开始数

- 定数组的长度

- 数组名.length = 数字;

- 清空数组

- length = 0;

### 向数组最后追加新元素

- 数组名[数组名.length-1] = 数据;

### 数组和伪数组的区别

- 相同点：集合中的数据都是有序的索引、都有 length 属性、都能够遍历
- 不同点：伪数组不是 Array 类型，无法使用数组中的方法

### 遍历数组所有元素

- for(var i = 0;i < nums.length;i++) {
  document.write('<h2>' + nums[i] + '</h2>');
  }

### 冒泡排序

- for(var i = 1;i <= nums.length-1;i++) {
  for(var j = 1;j <= nums.length-i;j++) {
  if(nums[j-1] > nums[j]) {
  var temp = nums[j-1];
  nums[j-1] = nums[j];
  nums[j] = temp;
  }
  }
  }

      - 比较轮数  <=数组.length-1
      - 比较次数  <=数组.length-当前轮数

- for(var i = 0;i < nums.length-1;i++) {
  for(var j = 0;j < nums.length-1-i;j++) {
  if(nums[j] > nums[j+1]) {
  var temp = nums[j];
  nums[j] = nums[j+1];
  nums[j+1] = temp;
  }
  }
  }

      - 比较轮数  <数组.length-1
      - 比较次数  <数组.length-当前轮数-1

## 函数（Function）

### 一个功能，功能是可以反复调用

- 引用数据类型（Function），函数在 js 中也是一种复杂数据类型
- 封装性，将执行代码封闭在一个独立的执行环境中

### 声明创建与调用

- 创建函数声明

- function 函数名() {

// 函数体
}\*\*

- 调用函数

- 函数名();

### 函数参数

- 形参

- 在函数创建时，在小扩号中定义的标识符（占位符）

- 实参

- 在函数调用时，在小扩号中所传入的实际的数据
- 数组 / 变量 / 函数 / 对象 都可以作为参数传递

- 关系

- 实参会传入给形参，关系是一一对应的
- 若形参没有接收的实参，默认值是 undefined，不会报错

### 函数的返回值（return 关键字）

- return 数据；
- 1 将数据返回给调用者，调用者可以用变量接收函数返回的结果

- 没有数据返回 undefined

- 2 终止函数的执行

### 作用域

- 变量可访问的范围
- 全局作用域

- 函数之外的执行环境
- 全局变量

- 在全局作用域（函数体外）中用 var 关键字创建的变量
- 程序的任何地方

- 局部作用域

- 函数体内的执行环境
- 局部变量

- 在局部作用域（函数体）中用 var 关键字定义的变量

  - 形参也是局部变量

- 只能在本函数体内
- 每次调用函数，函数中的局部变量始终是新的变量，上一次的局部变量操作，默认不会影响下一次变量操作

- 作用域链

- 当访问一个变量时，会先从本作用域中去找这个变量，若找不到则向上一级作用域中去找，依次类推，就形成了一个作用域链

### 预解析

- 概念：程序在执行之前，有个预备过程
- 把 var 关键字所声明的变量名（ 只有变量名），提升到当前执行环境（作用域）的顶部
- 把用函数声明所创建的函数（ 函数整体），提升到当前执行环境（作用域）的顶部

### 函数创建方式

- 函数声明

- function 函数名() {

// 函数体
}\*\*

- 函数表达式

- var 变量名 = function() {

// 函数体
};\*\*

- new 关键字

- var 变量名 = new Function('参数 1'，'参数 2'，...,'函数体中的代码');

- 不推荐使用

- 区别

- 函数声明：在提升的时候，提升的是函数整体
- 函数表达式：在提升的时候，提升的是变量名

### 匿名函数和自调用函数

- 匿名函数就是没有名字的函数，在 js 中配合任意运算符，为了匿名函数不报错
- 常用匿名函数表现方式

- (function( ){
  // 函数体

}); - !function( ){}; - -function( ){}; - ++function( ){};\*\*

- 匿名函数表达式调用

- var 变量名 = function( ) {

// 函数体;
};\*\*

- 变量名( ) => (function( ) { })( );

- 自调用函数（自执行函数）

- (function(形参 1,形参 2) {
  // 函数体

}(实参 1,实参 2)); - 让匿名函数创建后马上调用执行，只能调用一回 - 任何形式函数都可以自调用（自执行）\*\*

- 匿名函数作用（利用局部作用域）

- 模拟块级作用域

- 块级作用域：在分支结构或者循环结构的代码块中所定义的变量，仅仅只能在本结构中使用
- 在 js 中（ES6 之前）不存在块级作用域

- 避免全局变量污染（全局变量命名冲突）

### 函数体内的 arguments

- 只有在函数体内提供的一个伪数组
- 可以获取用户传入的所有实参

- 针对用户传入的实参个数不确定时可以选用，其他情况依然要写实参

- arguments.length; 参数的个数
  arguments[索引]; 获取一个实参

### 全局变量的特殊情况

- var a = 123;
  function fn() {
  // 在此，a 没有使用 var 关键字创建变量或传入形参
  // 若[直接赋值]时，代码在执行到这一行，会把 a 变成全局变量(重新赋值)
  a = 456;
  }
  fn();
  alert(a); // 不报错

## 对象

### 类（构造函数）和对象的关系

- 类： 抽象出的模板

- class 关键字，ES6 之前没有类的概念，之前都是通过[构造函数]模拟出类
- 构造函数

- 内置的：Object、Date、Array 等
- 自定义：自己创建的构造函数

- 对象：具体的实例

- 万物皆对象，任何事物都可以被抽象成对象
- 对象是一个容器，封装了[属性]和[方法](键值对)

- 属性：对象的静态特征
- 方法：对象的动态特征，指对象的一种功能或行为

  - 方法的值用函数来表示

- 创建对象得通过类（构造函数）创建

- new 构造函数();
- 对象名 instanceof 构造函数名;

### 对象创建

- 创建方式

- new 关键字调用系统提供 Object 构造函数

  - 创建一个对象： var 变量名 = new Object();

Object 构造函数简写： var 变量名 = {};\*\*

- 创建并调用自定义构造函数

      - function 函数名(参数1,参数2,参数3...){

  this.键 = 参数 1；
  this.键 = 参数 2；
  this.键 = function（） {
  console.log('参数 3')；

}
var v = new 函数名(实参 1，实参 2，实参 3)； - 构造函数命名首字母要大写（帕斯卡命名法） - this 表示当前通过 new 创建的对象\*\*

- new 关键字的作用

- 通过调用构造函数创建对象，属性和方法的集合
- 执行过程

- 1 函数调用时，在内存中申请一块空间，存放要创建的对象
- 2 在构造函数内部，让 this 关键字指向当前创建的对象内存空间
- 3 通过 this 给这个内存空间的对象中添加属性和方法
- 4 将创建好（赋值过）的对象返回给外部的变量名

- 对象方法中的 this 关键字的指向

- this 在构造函数中，指向当前创建的对象
- this 在方法调用中，指向方法的调用者（点前边的东西）

- 构造函数和自定义构造函数的区别

- 系统提供的构造函数创建的对象，叫内置对象
- 自定义构造函数创建的对象，叫自定义对象

- 普通函数和构造函数的区别

- 调用方式不同

- 普通函数，直接调用
- 构造函数，需要通过 new 关键字调用

- 命名规则不同

- 普通函数，驼峰命名法

  - 第二个单词开始首字母大写

- 构造函数，帕斯卡命名法

  - 首字母要大写

- 目的不同

- 普通函数，实现一些小功能
- 构造函数，创建对象

### 对象操作

- 对象组织数据的方式

- 键值对 key:value

- 不同键值对用逗号隔开，最后一个不用

- 键，指属性名或方法名，命名规范和变量名普通函数一样
- 值，指实际的数据

- 设置属性和方法

- 对象名.键名 = 值;

  - var dog1 = {};

dog1.name = '旺财';
dog1.call = function(){
alert(this.name + '在汪汪叫...')
} - 在点一个变量时，此时该字符不再具有变量的意义，而是普通字符\*\*

- 对象名['键名'] = 值;

  - var dog2 = {};

dog2['name'] = '旺财'\*\*

- 获取属性和调用方法

- 对象.键名;
- 对象['键名'];

  - 在中括号中，该变量具有变量的意义

如果对象的属性名为字符串类型，必须使用这种方式\*\*

- 删除属性和方法

- delete 对象.键名;

- 删除之后访问是 undefiend

- delete 对象['键名'];
- 若访问的成员不存在，返回 undefined

- 检测属性或方法

- 对象.hasOwnProperty('键名');

- 存在 true
- 不存在 false

- 检测对中是否还有属性或方法

- console.log(dog1.hasOwnProperty('name'));

- 检测对象的类型

- 对象 instanceof 构造函数名;

  - 属于 true
  - 不属于 false

- 检测数据（基本数据类型）用 typeof

检测对象（引用数据类型）用 instanceof\*\*

- 遍历对象的成员 for-in

- 一组无序的数据集合

  - 数组是一组有序的数据集合（有索引）

- key，遍历取出对象中的每一个键名

      - for(var key in student){

  console.log(key);

}\*\*

- 对象[key]→ 变量，遍历取出对象中的每一个键名的值

      - for(var key in student){

  console.log(student[key]);

}\*\*

### 基本数据类型和引用数据类型的区别

- 分类

- 基本数据类型（简单的数据类型、值类型）

- 数字 Number、字符串 String、布尔 Boolean、未定义 Undefined、空 Null

- 引用数据类型（复杂的数据类型、引用类型）

- 数组 Array、函数 Function、对象 Object 等

- 内存中的栈和堆

- 在 js 中不存在栈和堆的概念，目的是为了区分基本数据类型和引用数据类型
- 栈和堆

- 在内存中存储方式不一样
- 栈区：用来存储用[基本数据类型]的数据、地址和[引用数据类型]的地址
- 堆区：用来存储[引用数据类型]的数据

- 基本类型数据传递给函数的参数时

- 基本类型数据在复制时（一个变量名赋值给另一个新的变量名）

栈区中存放的地址和数据都会被重新复制一份新的，新变量指向栈区新的地址和新的数据\*\*

- 引用类型数据传递给函数的参数时

- 引用类型数据在复制时（一个变量名赋值给另一个新的变量名）

栈区中存放的地址会被重新复制一份新的，堆区的数据不会被复制，新变量指向新的地址和原有的堆区数据\*\*

- 深浅拷贝

- 浅拷贝

- 针对赋值数据成员，拷贝时，仅仅拷贝地址，堆中的数据没有被拷贝

- 深拷贝

- 在栈中开辟新的空间存堆空间中数据的地址，在堆中开辟新的空间拷贝堆中父对象的数据

## 内置对象

### 内置对象、宿主对象、自定义对象的区别

- 内置对象

- 系统所提供的对象

  - 基本对象：Object、Function、Boolean、Symbol

数字和日期对象：Math、Date、Number
字符串对象：String、RegExp
可索引的集合对象：Array\*\*

- 自定义对象

- 自定义构造函数所创建的对象

- 宿主对象（浏览器宿主， Node 宿主）

- JS 所运行的环境提供的对象

- BOM 中的 Window、DOM 中的 Document

### Math 对象

- Math 本身就是一个内置对象，不需要再通过构造函数去创建
- 常用属性和方法

- Math.PI; π
- Math.abs(数字); 获取一个数字的绝对值
- Math.round(数字); 四舍五入
- Math.ceil(数字); 向上取整
- Math.floor(数字); 向下取整
- Math.pow(x,y); 返回 x 的 y 次方
- Math.max(数字,数字,数字...); 求最大数
- Math.min(数字,数字,数字...); 求最小数
- Math.random(); 随机数[0,1);

- 前包后不包

### Date 类型对象

- JS 提供的日期和时间的操作接口

- 1970 年 1 月 1 日 00:00:00 前后的各 1 亿天（单位为毫秒）

- 是系统内置的构造函数，若想要操作时间，必须创建 Date 类型对象
- 创建 Date 类型对象

- 创建当前时间对象

  - var 变量名 = new Date();

- 创建指定的时间对象

  - var 变量名 = new Date(stringdate);
  - new Date('year-month-date hh:mm:ss')
  - new Date('year/month/date hh:mm:ss')

- 创建 1970 年后 value 毫秒后的时间对象

  - var 变量名 = new Date(value);
  - new Date(999999999999)

- 创建指定时间对象（非字符串方式）

传参：年、月、日、时、分、秒、毫秒\*\*

- var 变量名 = new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);
- month 的范围是 [0-11]
- [年月]必填，其他选填

- 操作 Date 类型对象方法

- 获取/设置年月日

- 年：日期对象.getFullYear() / 日期对象.setFullYear(数字)
- 月：日期对象.getMonth() / 日期对象.setMonth(数字)

  - 获取月份是从 0 开始的

- 日：日期对象.getDate() / 日期对象.setDate(数字)

- 获取/设置时分秒

- 时：日期对象.getHours() / 日期对象.setHours(数字)
- 分：日期对象.getMinutes() / 日期对象.setMinutes(数字)
- 秒：日期对象.getSeconds() / 日期对象.setMinutes(数字)
- 毫秒：对象. getMilliseconds() / 对象.setMilliseconds(数字)

- 获取星期数

- 日期对象.getDay();

  - 周一 0 到周六 6

- 获取/设置 1970 年至指定时间的总毫秒数

- 日期对象.getTime() / 日期对象.setTime(数字);

### Array 类型对象

- 数组创建方式

- 数组字面量

- var 数组名 = [数据,数据,数据];

- 构造函数 Array

- var 数组名 = new Array(数据,数据,数据);

- 特殊对象：数组中的数据是有编号的（索引、下标）、有序的

- 键值对 key

- 数组对象常用的方法

- 向前后数组中添加元素

  - 数组名.unshift(newelement1,newelement2,....,newelementX);

    - 向数组的开头添加一个或更多元素，并返回新的长度（原数组会发生变化）

  - 数组名.push(newelement1,newelement2,....,newelementX);

    - 向数组的末尾添加一个或更多元素，并返回新的长度（原数组会发生变化）

- 从数组前后删除一个元素

  - 数组名.shift();

    - 删除并返回数组的第一个元素（原数组会发生变化）

  - 数组名.pop();

    - 删除并返回数组的最后一个元素（原数组会发生变化）

- 数组任意位置的添加、删除

  - 数组名.splice(index,howmany,item1,.....,itemX)

    - index 表示从哪开始删

howmany 表示删除多少个
item 添加的数据\*\*

- 从数组中添加/删除项目，然后返回修改后的项目（原数组会发生变化）
- 修改 要先删除后增加

- 数组元素的查询

  - 数组名.indexOf(searchElement[,formIndex]);

    - formIndex 表示从哪个位置开始查找
    - 返回在数组中查找的第一个指定元素的索引

如果不存在，返回-1\*\*

- 数组名.lastIndexOf(searchElement);

  - 返回在数组中查找的最后一个指定元素的索引

如果不存在，返回-1\*\*

- 数组的反转和排序

      - 反转

      	- 数组名.reverse();

      - 排序

      	- 升序（从小到大）

      		- 数组名.sort(function(a,b){

  return a - b;

})\*\*

- 降序（从大到小）

      		- 数组名.sort(function(a,b){

  return b - a;

})\*\*

- 数组截取

  - 数组名.slice(start[,end]);

    - 截取后不会改变原数组，从原数组中返回选定元素组成的新数组
    - 索引是前包后不包 [start,end)
    - 不传参，截取所有
    - 传一个，截取开始元素后的所有

- 数组元素的拼接成字符串

  - 数组名.join(separator);

    - 拼接后不会改变原数组，把原数组中的所有元素放入一个字符串中
    - 不传参 默认用，连接
    - 传'' 无连接
    - 传| 间隔连接
    - 字符串.split(sp);

      - 字符串分割成数组

- 数组拼接

  - 数组名.concat(arr2,arr3...);

    - 数组拼接其他的数组，返回拼接后的数组

- 数组的其他方法

  - 数组遍历

    - 数组名.forEach(function(value,index[,currentArray]){

console.log(index + '---' + value);
});\*\*

- 过滤出符合筛选条件的元素，返回一个新的数组

      	- 数组名.filter(function(value,index[,currentArray]){

  return 条件;

});\*\*

- 验证数组中的每一个元素是否都符合指定的条件，返回布尔值

      	- 数组名.every(function(value,index[,currentArray]){

  return 条件;

});\*\*

- 验证数组中的每一个元素是否有符合指定条件的，返回布尔值

      	- 数组名.some(function(value,index[,currentArray]){

  return 条件;

});\*\*

- 遍历数组中的每一个元素，更改后存入并返回一个新的数组

      	- 数组名.map(function(value,index[,currentArray]){

  return 操作;

});\*\*

- 数据结构-栈和队列

- JS 中没有栈和队列的概念，但是 js 可以通过数组的方法来模拟
- 栈

- 先进后出-FILO（First In Last Out）电梯

- 队列

- 先进先出-FIFO（First In First Out）排队买票

- 清空数组

- arr = [];
- arr.length = 0;
- arr.splice(0, arr.length);

### String 字符串对象

- 字符串的不可变性

- 重新给字符串（基本数据类型）赋值时，会重新在内存中开辟空间，原有的字符串数据不会被修改删除，依然在内存中等待释放
- 由于字符串的不可变，在大量拼接字符串的时候会有效率问题

- 基本包装对象（临时对象）

- 不是对象，但是可以像对象一样使用，使用后销毁
- 把普通字符串包装成对象

  - var str = 'abcdef';

// var strObj = new String('abcdef');
console.log(str.length);\*\*

- 把数字包装成对象

  - var a = 123;

a.toString();
// new Number(123);\*\*

- 变量 → 临时对象 相当于 new Number();

去调用 toString()\*\*

- 把布尔包装成对象

  - var isOk = true;

isOk.toString();
// new Boolean(true);\*\*

- 变量 → 临时对象 相当于 new Boolean();

去调用 toString()\*\*

- 字符串对象常用的办法

- 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串
- 获取字符串指定位置的单个字符

  - 字符串[index];

    - IE7 及以下不支持
    - 找不到返回 undefined

  - 字符串.charAt(index);

    - 找不到返回空字符串

- 字符串的拼接

  - 拼接符 +
  - 字符串.concat(str1,str2,str3...);

- 字符串的截取

  - 字符串.slice(star[,end]);

    - 截取后不会改变原字符串，从原字符串中返回两个指定下标之间的新字符串

索引是前包后不包 [start,end) - 可以使用负数作为参数\*\*

- 字符串.substring(start[,end]);

  - 截取后不会改变原字符串，从原字符串中返回两个指定下标之间的新字符串

索引是前包后不包 [start,end) - 不可以使用负数作为参数\*\*

- 字符串.substr(start[,length]);

  - 截取后不会改变原字符串，从原字符串中返回开始下标指定长度的新字符串

索引是前包后不包 [start,end) - 不符合 ECMAscript 标准，不建议使用\*\*

- 查询字符是否在字符串中存在

  - 字符串.indexOf(字符串[,字符串长度]);
  - 字符串.lastIndexOf();

- 去除空白符

  - 字符串.trim();

    - 只会去除字符串两边的空格
    - 兼容 IE9 以上

- 字母字符大小写转换

  - 字符串.toUpperCase();

    - 转换大写

  - 字符串.toLowerCase();

    - 转换小写

- 单个字符串替换

  - 字符串.replace(oldStr,newStr);

    - 默认只变匹配的第一个字符

- 字符串分割成数组

  - 字符串.split(sp);

    - sp 指要切割的字符
    - 数组名.join(separator);

      - 数组的元素拼接成字符串
      - 全部删除字符串

        - 字符串.split(要删除的字符串).join('');

      - 全部替换字符串

        - 字符串.split(要替换的字符串).join(替换成什么字符串);

```

```

```

```
